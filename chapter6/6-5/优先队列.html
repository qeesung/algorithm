<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>优先队列</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><p><div class="toc"><div class="toc">
<ul>
<li><a href="#优先队列">优先队列</a><ul>
<li><a href="#优先队列基础知识">优先队列基础知识</a></li>
<li><a href="#优先队列c实现">优先队列C实现</a></li>
</ul>
</li>
</ul>
</div>
</div>
</p>



<h1 id="优先队列">优先队列</h1>

<p>我们在之前讲过的<a href="http://blog.csdn.net/ii1245712564/article/details/45505799">《堆的基础知识》</a>和<a href="http://blog.csdn.net/ii1245712564/article/details/45534625">《堆排序》</a>之后，我们来讲讲最大堆和最小堆的具体应用<strong>优先队列</strong>！</p>



<h2 id="优先队列基础知识">优先队列基础知识</h2>

<p>我们来看看这样的场景，给定你一组数据，要你在这组数据里面找到最大的那个数据，你要怎么做？</p>

<ul>
<li>你可能会说直接遍历一次就行啦,运行时间也就<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-1-Frame" role="textbox" aria-readonly="true"><nobr><span class="math" id="MathJax-Span-1" style="width: 2.776em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.189em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.816em 1000.003em 3.149em -0.424em); top: -2.717em; left: 0.003em;"><span class="mrow" id="MathJax-Span-2"><span class="mi" id="MathJax-Span-3" style="font-family: MathJax_Math-italic;">O</span><span class="mo" id="MathJax-Span-4" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-5" style="font-family: MathJax_Math-italic;">n</span><span class="mo" id="MathJax-Span-6" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 2.723em;"></span></span></span><span style="border-left-width: 0.003em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.403em; vertical-align: -0.397em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-1">O(n)</script>,但是如果要求你在这堆数据里面找到最大的，然后删除，再在剩下的元素里面找到最大的，那还是要遍历一般所有数据。那有没有其他快速的方法呢？</li>
<li>以<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-2-Frame" role="textbox" aria-readonly="true"><nobr><span class="math" id="MathJax-Span-7" style="width: 5.069em; display: inline-block;"><span style="display: inline-block; position: relative; width: 4.056em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.816em 1000.003em 3.149em -0.424em); top: -2.717em; left: 0.003em;"><span class="mrow" id="MathJax-Span-8"><span class="mi" id="MathJax-Span-9" style="font-family: MathJax_Math-italic;">O</span><span class="mo" id="MathJax-Span-10" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-11" style="font-family: MathJax_Math-italic;">n</span><span class="mi" id="MathJax-Span-12" style="font-family: MathJax_Math-italic;">l</span><span class="mi" id="MathJax-Span-13" style="font-family: MathJax_Math-italic;">o</span><span class="mi" id="MathJax-Span-14" style="font-family: MathJax_Math-italic;">g<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-15" style="font-family: MathJax_Math-italic;">n</span><span class="mo" id="MathJax-Span-16" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 2.723em;"></span></span></span><span style="border-left-width: 0.003em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.403em; vertical-align: -0.397em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-2">O(nlogn)</script>将这些数据排序，想要第几大的直接取出来就可以啦，那如果要是向这堆数据里面插入一个新的数据怎么办？这时你可能要遍历性这些有序的数据，插入到合适的位置，这样不就行啦。不错，可是这样一次插入操作时间代价为<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-3-Frame" role="textbox" aria-readonly="true"><nobr><span class="math" id="MathJax-Span-17" style="width: 2.776em; display: inline-block;"><span style="display: inline-block; position: relative; width: 2.189em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.816em 1000.003em 3.149em -0.424em); top: -2.717em; left: 0.003em;"><span class="mrow" id="MathJax-Span-18"><span class="mi" id="MathJax-Span-19" style="font-family: MathJax_Math-italic;">O</span><span class="mo" id="MathJax-Span-20" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-21" style="font-family: MathJax_Math-italic;">n</span><span class="mo" id="MathJax-Span-22" style="font-family: MathJax_Main;">)</span></span><span style="display: inline-block; width: 0px; height: 2.723em;"></span></span></span><span style="border-left-width: 0.003em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.403em; vertical-align: -0.397em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-3">O(n)</script>,这样也太慢了。要是你随意改变这堆数据里面的一个元素的话，那就要把这个改变的元素移动到合适的位置保证这堆数据还是有序的，特别是将这堆数据放在一个数组里面，插入一个新的元素会涉及到数组元素的移动。。。可以慢到抓狂了。</li>
</ul>

<p>那有没有一种比较快速的方法可以做到在最少的时间代价内从一个元素个数和元素大小都会改变的一堆数据中找到最大/最小的那个。那就得优先队列出马啦！</p>

<p><strong>优先队列</strong>的基础是最大堆/最小堆，是用来维护一组元素构成的集合<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-4-Frame" role="textbox" aria-readonly="true"><nobr><span class="math" id="MathJax-Span-23" style="width: 0.909em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.696em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.709em 1000.003em 2.723em -0.424em); top: -2.557em; left: 0.003em;"><span class="mrow" id="MathJax-Span-24"><span class="mi" id="MathJax-Span-25" style="font-family: MathJax_Math-italic;">S<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.056em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.563em;"></span></span></span><span style="border-left-width: 0.003em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.07em; vertical-align: -0.063em;"></span></span></nobr></span><script type="math/tex" id="MathJax-Element-4">S</script>的数据结构，每一个元素都有一个相关的值，称之为<code>key</code>.</p>

<blockquote>
  <p><strong>一个最大优先队列支持如下操作:</strong></p>
  
  <ul>
  <li><strong>MAXIMUM(pQueue)</strong>:得到<code>pQueue</code>里面<code>key</code>值最大的元素</li>
  <li><strong>EXTRACT-MAX(pQueue)</strong>：得到<code>pQueue</code>里面<code>key</code>值最大的元素，并将这个元素从优先队列里面删除</li>
  <li><strong>INSERT(pQueue  , E)</strong>:在<code>pQueue</code>里面插入一个新的元素<code>E</code></li>
  <li><strong>INCRESED-KEY(pQueue  , POS , NEWKEY)</strong>：将<code>pQueue</code>里面位置<code>POS</code>的元素<code>key</code>值设为<code>NEWKEY</code></li>
  </ul>
</blockquote>

<p>最大优先队列在实际的应用中有非常多的用处，比如在计算机系统里面的任务，每一个任务都有一个优先级，每一个时刻都有可能添加(<strong>INSERT</strong>)的任务，计算机应该在这些任务里面得到优先级最高(<strong>EXTRAXCT-MAX</strong>)的任务优先进行处理。</p>

<p>相应的，最小优先队列里面应该有以下操作:<strong>MINIMUM</strong>,<strong>INSERT</strong>,<strong>EXTRACt-MIN</strong>,<strong>DECREASE-KEY</strong>等操作，最小优先队列可以作为基于事件驱动的模拟器。队列中要保存模拟的事件，每一个事件都以事件发生时间作为<strong>关键字</strong>。每次提出(<strong>EXTRACT-MIN</strong>)队列里面的发生时间最早的，每一时刻都有新的时间插入到队列里面去(<strong>INSERT</strong>)。</p>



<h2 id="优先队列c实现"><i class="icon-code"></i>优先队列C++实现</h2>

<p>下面实现了优先队列的四个操作！ <br>
<font color="red">注意<code>array</code>是最大堆，对元素从1开始，0位置存放堆大小</font></p>

<blockquote>
  <p><strong>MAXIMUM</strong></p>
  
  <ul>
  <li>得到优先队列里面的最大值</li>
  <li>@param  array 输入的优先队列   </li>
  <li>@return       堆里面的最大值 <br>
  <pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> maximum(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[])
{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span> == NULL || <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)
    {
        <span class="hljs-built_in">cerr</span>&lt;&lt;<span class="hljs-string">"The prority queue is EMPTY"</span>&lt;&lt;endl;
        <span class="hljs-keyword">return</span> INT_MIN;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">1</span>];
}</code></pre></li>
  </ul>
  
  <p>这个代码很简单，直接返回最大堆的堆顶元素<code>array[1]</code>就可以啦</p>
</blockquote>

<hr>

<blockquote>
  <p><strong>EXTRACT-MAX</strong></p>
  
  <ul>
  <li>取出优先队列里面的最大值</li>
  <li>@param  array 优先队列</li>
  <li>@return       最大值 <br>
  <pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">int</span> extractMax(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[])
{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span> == NULL || <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)
    {
        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"The priority queue is EMPTY"</span>&lt;&lt;endl;
        <span class="hljs-keyword">return</span> INT_MIN;
    }
    <span class="hljs-keyword">int</span> maxNum = <span class="hljs-built_in">array</span>[<span class="hljs-number">1</span>];
    <span class="hljs-built_in">array</span>[<span class="hljs-number">1</span>] = <span class="hljs-built_in">array</span>[<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]];
    <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]--;
    maxHeapify(<span class="hljs-built_in">array</span> , <span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span> maxNum;
}</code></pre></li>
  </ul>
  
  <p>我们用堆末尾的元素替换到堆顶，然后再将这个堆顶元素进行堆性质的维护，将这个堆顶元素沉降到合适的位置！最后返回最大值</p>
</blockquote>

<hr>

<blockquote>
  <p><strong>INCREASE-KEY</strong></p>
  
  <ul>
  <li>增加一个优先队列里面元素的键值</li>
  <li>@param array       优先队列</li>
  <li>@param pos         位置</li>
  <li>@param newKeyValue 新的键值 <br>
  <pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> increseKey(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[] , <span class="hljs-keyword">int</span> pos , <span class="hljs-keyword">int</span> newKeyValue)
{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span> == NULL || pos &gt; <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] || newKeyValue &lt; <span class="hljs-built_in">array</span>[pos])
    {
        <span class="hljs-built_in">cerr</span>&lt;&lt;<span class="hljs-string">"increse new key value failed"</span>&lt;&lt;endl;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-built_in">array</span>[pos] = newKeyValue;
    <span class="hljs-keyword">while</span>(pos &gt; <span class="hljs-number">1</span>)
    {
        <span class="hljs-keyword">int</span> fatherPos = PARENT(pos);
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[pos] &gt; <span class="hljs-built_in">array</span>[fatherPos])
        {
            exchange(<span class="hljs-built_in">array</span> , pos , fatherPos);
            pos = fatherPos;
        }
        <span class="hljs-keyword">else</span> 
            <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">return</span>;
}</code></pre></li>
  </ul>
  
  <p>这里代码有点长，但是做的事情很简单，某一个位置的<code>key</code>值变大了，那么他的子树还是满足性质的，只是我们不能保证这个改变的节点使得<code>array[PARENT(i)]</code>&gt;<code>array[i]</code>,于是我们需要将这个节点元素和父节点比较，如果父节点比较大，那么不做任何操作，要是子节点比较大，那么子节点与父节点交换，将这个较大的元素向上移动，这样循环操作直到到了父节点更大的情况或者到了根节点！ <br>
  <img src="http://img.blog.csdn.net/20150507203228303" alt="Alt text" title=""></p>
</blockquote>

<hr>

<blockquote>
  <p><strong>INSERT</strong></p>
  
  <ul>
  <li>在优先队列一个插入一个元素</li>
  <li>@param array   优先队列</li>
  <li>@param element 将要插入的元素 <br>
  <pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> insert(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[] , <span class="hljs-keyword">int</span> element)
{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span> == NULL)
        <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] &gt;= <span class="hljs-number">19</span>)
    {
        <span class="hljs-built_in">cerr</span>&lt;&lt;<span class="hljs-string">"Thy  priority queue is FULL"</span>&lt;&lt;endl;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]++;
    <span class="hljs-built_in">array</span>[<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]] = INT_MIN;
    increseKey(<span class="hljs-built_in">array</span> , <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>], element);
}</code></pre></li>
  </ul>
  
  <p>这里用到了<code>increseKey</code>这个函数，我们在堆末尾插入一个新的元素，赋值为<code>INT_MIN</code>，然后将这个值赋值为<code>element</code>上移到合适的位置！</p>
</blockquote>

<hr>

<p>下面是完整代码 <br>
<strong>All Code</strong></p>

<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">/*************************************************
* @Filename:    pQueue.cc
* @Author:      qeesung
* @Email:       qeesung@qq.com
* @DateTime:    2015-05-07 16:49:55
* @Version:     1.0
* @Description: 优先队列
**************************************************/</span>


<span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;climits&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-comment">/**
* 优先队列的基本操作
*/</span>
<span class="hljs-preprocessor">#define PARENT(i) ((i)&gt;&gt;1)</span>
<span class="hljs-preprocessor">#define LEFTCHILD(i) ((i)&lt;&lt;1)</span>
<span class="hljs-preprocessor">#define RIGHTCHILD(i) (((i)&lt;&lt;1)+1)</span>
<span class="hljs-preprocessor">#define MAX_HEAP_ARRAY_SIZE 20</span>

<span class="hljs-comment">/**
 * 交换数组的两个位置的元素
 * @param array 目标数组
 * @param pos1  位置1
 * @param pos2  位置2
 */</span>
<span class="hljs-keyword">void</span> exchange(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[] , <span class="hljs-keyword">int</span> pos1 , <span class="hljs-keyword">int</span> pos2)
{
    <span class="hljs-keyword">int</span> temp = <span class="hljs-built_in">array</span>[pos1];
    <span class="hljs-built_in">array</span>[pos1] = <span class="hljs-built_in">array</span>[pos2];
    <span class="hljs-built_in">array</span>[pos2] = temp;
}

<span class="hljs-comment">/**
 * 维护最大堆的性质
 * @param array 输入的最大堆
 * @param pos   维护的位置
 */</span>
<span class="hljs-keyword">void</span> maxHeapify(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[] , <span class="hljs-keyword">int</span> pos)
{
    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">array</span> == NULL | pos &gt; <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>])
        <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">int</span> leftChild = LEFTCHILD(pos);
    <span class="hljs-keyword">int</span> rightChild = RIGHTCHILD(pos);
    <span class="hljs-keyword">int</span> maxPos = pos;
    <span class="hljs-keyword">if</span>(leftChild &lt;= <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] &amp;&amp; \
        <span class="hljs-built_in">array</span>[leftChild] &gt; <span class="hljs-built_in">array</span>[maxPos])
        maxPos = leftChild;
    <span class="hljs-keyword">if</span>(rightChild &lt;= <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] &amp;&amp; \
        <span class="hljs-built_in">array</span>[rightChild] &gt; <span class="hljs-built_in">array</span>[maxPos])
        maxPos = rightChild;
    <span class="hljs-keyword">if</span>(maxPos != pos)
    {
        exchange(<span class="hljs-built_in">array</span> , maxPos , pos);
        maxHeapify(<span class="hljs-built_in">array</span> , maxPos);
    }
}


<span class="hljs-comment">/**
 * 建堆
 * @param array 将要建堆的数组
 */</span>
<span class="hljs-keyword">void</span> buildHeap(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[])
{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span> == NULL || <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> ;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]/<span class="hljs-number">2</span> ; k &gt;= <span class="hljs-number">1</span>  ; --k)
    {
        maxHeapify(<span class="hljs-built_in">array</span> , k);
    }
}

<span class="hljs-comment">/**
 * 下面是优先队列的基本操作
 */</span>


<span class="hljs-keyword">void</span> increseKey(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[] , <span class="hljs-keyword">int</span> pos , <span class="hljs-keyword">int</span> newKeyValue);
<span class="hljs-comment">/**
 * 在优先队列一个插入一个元素
 * @param array   优先队列
 * @param element 将要插入的元素
 */</span>
<span class="hljs-keyword">void</span> insert(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[] , <span class="hljs-keyword">int</span> element)
{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span> == NULL)
        <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] &gt;= <span class="hljs-number">19</span>)
    {
        <span class="hljs-built_in">cerr</span>&lt;&lt;<span class="hljs-string">"Thy  priority queue is FULL"</span>&lt;&lt;endl;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]++;
    <span class="hljs-built_in">array</span>[<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]] = INT_MIN;
    increseKey(<span class="hljs-built_in">array</span> , <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>], element);
}

<span class="hljs-comment">/**
 * 得到优先队列里面的最大值
 * @param  array 输入的优先队列   
 * @return       堆里面的最大值
 */</span>
<span class="hljs-keyword">int</span> maximum(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[])
{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span> == NULL || <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)
    {
        <span class="hljs-built_in">cerr</span>&lt;&lt;<span class="hljs-string">"The prority queue is EMPTY"</span>&lt;&lt;endl;
        <span class="hljs-keyword">return</span> INT_MIN;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">1</span>];
}

<span class="hljs-comment">/**
 * 取出优先队列里面的最大值
 * @param  array 优先队列
 * @return       最大值
 */</span>
<span class="hljs-keyword">int</span> extractMax(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[])
{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span> == NULL || <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)
    {
        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"The priority queue is EMPTY"</span>&lt;&lt;endl;
        <span class="hljs-keyword">return</span> INT_MIN;
    }
    <span class="hljs-keyword">int</span> maxNum = <span class="hljs-built_in">array</span>[<span class="hljs-number">1</span>];
    <span class="hljs-built_in">array</span>[<span class="hljs-number">1</span>] = <span class="hljs-built_in">array</span>[<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]];
    <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]--;
    maxHeapify(<span class="hljs-built_in">array</span> , <span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span> maxNum;
}

<span class="hljs-comment">/**
 * 增加一个优先队列里面元素的键值
 * @param array       优先队列
 * @param pos         位置
 * @param newKeyValue 新的键值
 */</span>
<span class="hljs-keyword">void</span> increseKey(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[] , <span class="hljs-keyword">int</span> pos , <span class="hljs-keyword">int</span> newKeyValue)
{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span> == NULL || pos &gt; <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] || newKeyValue &lt; <span class="hljs-built_in">array</span>[pos])
    {
        <span class="hljs-built_in">cerr</span>&lt;&lt;<span class="hljs-string">"increse new key value failed"</span>&lt;&lt;endl;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-built_in">array</span>[pos] = newKeyValue;
    <span class="hljs-keyword">while</span>(pos &gt; <span class="hljs-number">1</span>)
    {
        <span class="hljs-keyword">int</span> fatherPos = PARENT(pos);
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[pos] &gt; <span class="hljs-built_in">array</span>[fatherPos])
        {
            exchange(<span class="hljs-built_in">array</span> , pos , fatherPos);
            pos = fatherPos;
        }
        <span class="hljs-keyword">else</span> 
            <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-comment">/**
 * 打印优先队列
 * @param array 优先队列
 */</span>
<span class="hljs-keyword">void</span> printQueue(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[])
{
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"heap size : "</span>&lt;&lt;<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]&lt;&lt;<span class="hljs-string">" ----&gt;"</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>]; ++i)
    {
        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">array</span>[i]&lt;&lt;<span class="hljs-string">"\t"</span>;
    }
    <span class="hljs-built_in">cout</span>&lt;&lt;endl;
}


<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[]={<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">16</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">14</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>};
    <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"before builld heap:"</span>&lt;&lt;endl;
    printQueue(<span class="hljs-built_in">array</span>);
    buildHeap(<span class="hljs-built_in">array</span>);
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"after build heap:"</span>&lt;&lt;endl;
    printQueue(<span class="hljs-built_in">array</span>);
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"the max number is:"</span>&lt;&lt;maximum(<span class="hljs-built_in">array</span>)&lt;&lt;endl;
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"extract maximum is :"</span>&lt;&lt;extractMax(<span class="hljs-built_in">array</span>)&lt;&lt;endl;
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"after extract maximum number:"</span>&lt;&lt;endl;
    printQueue(<span class="hljs-built_in">array</span>);
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"increse pos 4 to 11:"</span>&lt;&lt;endl;
    increseKey(<span class="hljs-built_in">array</span> , <span class="hljs-number">4</span>, <span class="hljs-number">11</span>);
    printQueue(<span class="hljs-built_in">array</span>);
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"insert a new element 13:"</span>&lt;&lt;endl;
    insert(<span class="hljs-built_in">array</span> , <span class="hljs-number">13</span>);
    printQueue(<span class="hljs-built_in">array</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<blockquote>
  <p>运行结果： <br>
  before builld heap: <br>
  heap size : 10 —-&gt;4   1   3   2   16  9   10  14  8   7 <br>
  after build heap: <br>
  heap size : 10 —-&gt;16  14  10  8   7   9   3   2   4   1 <br>
  the max number is:16 <br>
  extract maximum is :16 <br>
  after extract maximum number: <br>
  heap size : 9 —-&gt;14   8   10  4   7   9   3   2   1 <br>
  increse pos 4 to 11: <br>
  heap size : 9 —-&gt;14   11  10  8   7   9   3   2   1 <br>
  insert a new element 13: <br>
  heap size : 10 —-&gt;14  13  10  8   11  9   3   2   1   7   </p>
</blockquote></div></body>
</html>